---
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: coder-applicationset
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
spec:
  goTemplate: true
  goTemplateOptions: ["missingkey=error"]
  syncPolicy:
    preserveResourcesOnDeletion: false
  generators:
    - merge:
        mergeKeys: [server]
        generators:
          - clusters:
              values:
                addonChart: coder
                namespace: coder
              selector:
                matchExpressions:
                  - key: in_cluster
                    operator: In
                    values: ['true']
          - clusters: {}
  template:
    metadata:
      name: '{{.values.addonChart }}-{{.name}}-{{.metadata.labels.environment}}'
    spec:
      project: '{{.metadata.annotations.argocd_project_name}}'
      source:
        helm:
          releaseName: '{{.values.addonChart}}'
          ignoreMissingValueFiles: true
          valueFiles:
            - $values/environments/common/addons/{{.values.addonChart}}/values.yaml
            - $values/environments/{{.metadata.labels.environment}}/addons/{{.values.addonChart}}/values.yaml
            - $values/clusters/{{.name}}/addons/{{.values.addonChart}}/values.yaml
          values: |
            coderHost: 'coder.ekslearning.{{ .metadata.annotations.aws_account_id }}.realhandsonlabs.net'
        repoURL: '{{.metadata.annotations.addons_repo_url}}'
        path: 'charts/{{ .values.addonChart }}'
        targetRevision: '{{.metadata.annotations.addons_repo_revision}}'
      destination:
        namespace: '{{ .values.namespace }}'
        name: '{{ .name }}'
      syncPolicy:
        automated: {}
        syncOptions:
          - CreateNamespace=true
          - ApplyOutofSyncOnly=true
          - validate=false
          - HelmLint=false
      retry:
        limit: 5
        backoff:
          duration: 5s
          maxDuration: 3m0s
          factor: 2
----------------------------
coder:
  coder:
    # You can specify any environment variables you'd like to pass to Coder
    # here. Coder consumes environment variables listed in
    # `coder server --help`, and these environment variables are also passed
    # to the workspace provisioner (so you can consume them in your Terraform
    # templates for auth keys etc.).
    #
    # Please keep in mind that you should not set `CODER_HTTP_ADDRESS`,
    # `CODER_TLS_ENABLE`, `CODER_TLS_CERT_FILE` or `CODER_TLS_KEY_FILE` as
    # they are already set by the Helm chart and will cause conflicts.
    env:
      - name: CODER_PG_CONNECTION_URL
        valueFrom:
          secretKeyRef:
            # You'll need to create a secret called coder-db-url with your
            # Postgres connection URL like:
            # postgres://coder:password@postgres:5432/coder?sslmode=disable
            name: coder-db-url
            key: url
      # For production deployments, we recommend configuring your own GitHub
      # OAuth2 provider and disabling the default one.
      - name: CODER_OAUTH2_GITHUB_DEFAULT_PROVIDER_ENABLE
        value: "false"

      # (Optional) For production deployments the access URL should be set.
      # If you're just trying Coder, access the dashboard via the service IP.
      #- name: CODER_ACCESS_URL
      #  value: "https://coder.ekslearning.767397688701.realhandsonlabs.net"

    #tls:
    #  secretNames:
    #    - my-tls-secret-name
    service:
      enable: true
      type: ClusterIP
    ingress:
      enable: true
        # The hostname to use for the ingress. This is the URL you will use to
        # access Coder. If you are using a custom domain, make sure to set up
        # the DNS records to point to the load balancer.
      host: coder.ekslearning.654654582602.realhandsonlabs.net
      annotations:
        # The ingress class to use for the ingress. This is used to specify
        # which ingress controller to use. If you are using AWS, you can
        # use the ALB ingress controller.
        kubernetes.io/ingress.class: alb
        # The ALB ingress controller will automatically create a load balancer
        # for you. You can specify the type of load balancer to create here.
        alb.ingress.kubernetes.io/load-balancer-type: application
        # The ALB ingress controller will automatically create a target group
        # for you. You can specify the type of target group to create here.
        alb.ingress.kubernetes.io/target-type: ip
        alb.ingress.kubernetes.io/scheme: internet-facing
        alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-west-2:654654582602:certificate/0464607c-059d-4412-bc49-5cea0e9f03dd
        #alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
        #alb.ingress.kubernetes.io/ssl-redirect: '443'
        # The ALB ingress controller will automatically create a security group
        # for you. You can specify the type of security group to create here.
        # The TLS secret to use for the ingress. This is used to terminate TLS
        # at the ingress controller. Make sure to create this secret in the
        # same namespace as Coder.
        #tlsSecret: tls-cert

  #external-dns.alpha.kubernetes.io/hostname: coder.ekslearning.767397688701.realhandsonlabs.net
  #service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
  #service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: ip
  #service.beta.kubernetes.io/aws-load-balancer-scheme: internet-facing
  #service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:us-west-2:767397688701:certificate/8974808c-117c-4a81-bf7c-98f236a01855
  #service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"
  #service.beta.kubernetes.io/aws-load-balancer-type: nlb

-----------------------------------
apiVersion: v2
name: coder
description: A Helm chart for coder

# A chart can be either an 'application' or a 'library' chart.
#
# Application charts are a collection of templates that can be packaged into versioned archives
# to be deployed.
#
# Library charts provide useful utilities or functions for the chart developer. They're included as
# a dependency of application charts to inject those utilities and functions into the rendering
# pipeline. Library charts do not define any templates and therefore cannot be deployed.
type: application

# This is the chart version. This version number should be incremented each time you make changes
# to the chart and its templates, including the app version.
# Versions are expected to follow Semantic Versioning (https://semver.org/)
version: 0.1.0

# This is the version number of the application being deployed. This version number should be
# incremented each time you make changes to the application. Versions are not expected to
# follow Semantic Versioning. They should reflect the version the application is using.
appVersion: "1.0.0"

dependencies:
- name: coder
  version: "2.20.2"
  repository:  https://helm.coder.com/v2

---------------
